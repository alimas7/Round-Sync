import groovy.json.JsonSlurper
import java.nio.file.Paths

ext {
    NDK_VERSION = project.properties['de.felixnuesse.extract.ndkVersion']
    NDK_TOOLCHAIN_VERSION = project.properties['de.felixnuesse.extract.ndkToolchainVersion']
    RCLONE_VERSION = project.properties['de.felixnuesse.extract.rCloneVersion']
    GO_REQ_VERSION = project.properties['de.felixnuesse.extract.goVersion']
    RCLONE_MODULE = 'github' + '.' + 'com/rclone/rclone'
    RCLONE_CUSTOM_VERSION_SUFFIX = '-extract'

    PROJECT_DIR = projectDir.absolutePath
    CACHE_PATH = Paths.get(PROJECT_DIR, 'cache').toString()
    GOPATH = Paths.get(CACHE_PATH, 'gopath').toString()
    OUTPUT_BASE_PATH = Paths.get(PROJECT_DIR, '..', 'app', 'lib').toAbsolutePath().toString()
}

def findSdkDir() {
    def androidHome = System.getenv('ANDROID_HOME')
    if (androidHome != null) return androidHome
    def localPropertiesFile = project.rootProject.file('local.properties')
    if (localPropertiesFile.exists()) {
        Properties properties = new Properties()
        properties.load(localPropertiesFile.newDataInputStream())
        return properties.get('sdk.dir')
    }
    throw new GradleException("Couldn't locate android SDK.")
}

def findNdkDir() {
    def sdkDir = findSdkDir()
    def ndkPath = Paths.get(sdkDir, 'ndk', NDK_VERSION).toAbsolutePath()
    return ndkPath.toString()
}

def getCrossCompiler(abi) {
    def osName = System.properties['os.name']
    def osArch = System.properties['os.arch']
    def os = osName.startsWith('Windows') ? 'windows-x86_64' : (osName.startsWith('Linux') ? 'linux-x86_64' : 'darwin-x86_64')
    def abiToCompiler = [
        'armeabi-v7a': "armv7a-linux-androideabi${NDK_TOOLCHAIN_VERSION}-clang",
        'arm64-v8a': "aarch64-linux-android${NDK_TOOLCHAIN_VERSION}-clang",
        'x86': "i686-linux-android${NDK_TOOLCHAIN_VERSION}-clang",
        'x86_64': "x86_64-linux-android${NDK_TOOLCHAIN_VERSION}-clang",
    ]
    return Paths.get(findNdkDir(), 'toolchains', 'llvm', 'prebuilt', os, 'bin', abiToCompiler[abi])
}

def getOutputPath(abi) {
    return Paths.get(OUTPUT_BASE_PATH, abi, 'librclone.so').toString()
}

def buildRclone(abi) {
    def abiToEnv = [
        'armeabi-v7a': ['GOARCH': 'arm', 'GOARM': '7'],
        'arm64-v8a': ['GOARCH': 'arm64'],
        'x86': ['GOARCH': '386'],
        'x86_64': ['GOARCH': 'amd64'],
    ]
    return {
        doLast {
            exec {
                environment 'GOPATH', GOPATH
                environment 'GOPROXY', 'direct'
                workingDir CACHE_PATH
                commandLine 'go', 'mod', 'tidy'
            }
            exec {
                environment 'GOPATH', GOPATH
                def crossCompiler = getCrossCompiler(abi)
                environment 'CC', crossCompiler
                environment 'CC_FOR_TARGET', crossCompiler
                environment 'GOOS', 'android'
                environment 'CGO_ENABLED', '1'
                environment 'CGO_LDFLAGS', '-fuse-ld=lld -Wl,--hash-style=both -s'
                abiToEnv[abi].each {entry -> environment entry.key, entry.value}
                workingDir CACHE_PATH
                def ldflags = "-buildid= -X ${RCLONE_MODULE}/fs.Version=${RCLONE_VERSION}${RCLONE_CUSTOM_VERSION_SUFFIX}"
                commandLine ('go', 'build', '-tags', 'android noselfupdate', '-trimpath', '-ldflags', ldflags, '-o', getOutputPath(abi), RCLONE_MODULE)
            }
        }
    }
}

task createRcloneModule(type: Exec) {
    onlyIf { !Paths.get(CACHE_PATH, 'go.mod').toFile().exists() }
    Paths.get(CACHE_PATH).toFile().mkdirs()
    workingDir CACHE_PATH
    environment 'GOPATH', GOPATH
    def d = '.'; def s = '/'
    def off = 'github' + d + 'com' + s + 'rclone' + s + 'rclone'
    def frk = 'github' + d + 'com' + s + 'alimas7' + s + 'rclone@a6bec48cd262'
    commandLine 'sh', '-c', "go mod init rclone && go mod edit -require ${off}@v1.70.1 && go mod edit -replace ${off}=${frk}"
}

task checkoutRclone(dependsOn: createRcloneModule) {
    doLast { println "Checkout handled by replacement." }
}

task buildArm(dependsOn: checkoutRclone) { configure buildRclone('armeabi-v7a') }
task buildArm64(dependsOn: checkoutRclone) { configure buildRclone('arm64-v8a') }
task buildx86(dependsOn: checkoutRclone) { configure buildRclone('x86') }
task buildx64(dependsOn: checkoutRclone) { configure buildRclone('x86_64') }

task buildAll {
    dependsOn buildArm, buildArm64, buildx86, buildx64
}

task clean {
    doLast {
        exec { environment 'GOPATH', GOPATH; commandLine 'go', 'clean', '-cache', '-modcache' }
        delete CACHE_PATH
        delete fileTree(OUTPUT_BASE_PATH).matching { include '**/librclone.so' }
    }
}

defaultTasks 'buildAll'
